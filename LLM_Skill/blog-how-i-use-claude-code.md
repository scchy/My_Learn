# 我如何使用 Claude Code

> 作者：Boris Tane  
> 原文：[How I Use Claude Code](https://boristane.com/blog/how-i-use-claude-code/)  
> 日期：2026年2月10日

---

我已经使用 [Claude Code](https://docs.anthropic.com/en/docs/claude-code) 作为主要开发工具大约9个月了，我形成的工作流程与大多数人使用 AI 编程工具的方式截然不同。

大多数开发者输入提示词，有时使用计划模式，修复错误，然后重复。那些更沉迷网络的人则在拼凑 ralph loops、mcps、gas towns（还记得那些吗？）等等。这两种方式的结果都是一团糟，对于任何非 trivial 的任务都会完全崩溃。

我将要描述的工作流程有一个核心原则：

> **在 Claude 编写代码之前，绝不让它开始，直到你审查并批准了书面计划。**

这种计划与执行的分离是我做的最重要的事情。它可以防止浪费精力，让我掌控架构决策，并且相比直接跳到代码，能用最少的 token 使用量产生显著更好的结果。

---

## 第一阶段：研究

每个有意义的任务都从一个**深度阅读指令**开始。我要求 Claude 在采取任何行动之前，彻底理解代码库的相关部分。而且我总是要求将研究结果写入一个持久的 markdown 文件，而不仅仅是聊天中的口头总结。

**示例提示词：**

```
深入阅读这个文件夹，深入理解它是如何工作的、它做什么以及它的所有细节。完成后，将你的学习和发现详细报告写入 research.md
```

```
详细研究通知系统，理解它的所有复杂之处，并撰写一份详细的 research.md 文档，包含关于通知如何工作的所有信息
```

```
仔细研究任务调度流程，深入理解它并寻找潜在的 bug。系统中肯定有 bug，因为它有时会运行本应被取消的任务。继续研究流程直到找到所有 bug，在找到所有 bug 之前不要停止。完成后，将你的发现详细报告写入 research.md
```

**注意语言中的关键词：**"深入地"、"详细地"、"复杂之处"、"仔细检查所有内容"。这些不是空话。没有这些词，Claude 只会略读。它会读取一个文件，看看函数的签名级别的作用，然后继续。你需要表明表面阅读是不可接受的。

**书面产物（research.md）至关重要。** 这不是为了让 Claude 做作业。它是我的审查界面。我可以阅读它，验证 Claude 是否真的理解了系统，并在任何计划开始之前纠正误解。如果研究是错误的，计划就会错误，实现也会错误。垃圾进，垃圾出。

这是 AI 辅助编码中最昂贵的失败模式，它不是错误的语法或糟糕的逻辑。**而是那些在孤立状态下工作但会破坏周围系统的实现。** 一个忽略了现有缓存层的函数。一个没有考虑 ORM 约定的迁移。一个重复了其他地方已有逻辑的 API 端点。研究阶段可以防止所有这些。

---

## 第二阶段：规划

一旦我审查了研究，我就会要求在一个单独的 markdown 文件中提供详细的实现计划。

**示例提示词：**

```
我想构建一个新功能 <名称和描述>，将系统扩展以实现 <业务成果>。撰写一份详细的 plan.md 文档，概述如何实现。包含代码片段
```

```
列表端点应该支持基于游标的分页而不是偏移量。撰写一份详细的 plan.md，说明如何实现。在建议更改之前阅读源文件，基于实际代码库制定计划
```

生成的计划总是包含对方法的详细解释、显示实际更改的代码片段、将要修改的文件路径，以及考虑和权衡。

我使用我自己的 `.md` 计划文件，而不是 Claude Code 内置的计划模式。内置的计划模式很糟糕。我的 markdown 文件给了我完全的控制权。我可以在编辑器中编辑它，添加内联注释，并且它作为项目中的真实产物持久存在。

**一个我经常使用的技巧：** 对于界限清晰的功能，如果我在开源仓库中看到过好的实现，我会将该代码作为参考与计划请求一起分享。如果我想添加可排序 ID，我会粘贴一个做得好的项目的 ID 生成代码，然后说"这是他们实现可排序 ID 的方式，撰写一份 plan.md 解释我们如何采用类似的方法。"当有具体的参考实现可以借鉴时，Claude 的工作效果会比从头设计要好得多。

但计划文档本身并不是有趣的部分。接下来发生的事情才是有趣的。

---

## 注释循环

这是我工作流程中最独特的部分，也是我增加最多价值的部分。

在 Claude 撰写计划后，我会在编辑器中打开它，并**直接在文档中添加内联注释**。这些注释纠正假设、拒绝方法、添加约束，或提供 Claude 不具备的领域知识。

注释的长度差异很大。有时注释只有两个词：在 Claude 标记为可选的参数旁边写上"不是可选的"。其他时候则是一段解释业务约束的文字，或粘贴一个代码片段显示我期望的数据结构。

**我会添加的一些真实注释示例：**

| 注释 | 说明 |
|------|------|
| "使用 drizzle:generate 进行迁移，而不是原始 SQL" | Claude 不具备的领域知识 |
| "不——这应该是 PATCH，不是 PUT" | 纠正错误假设 |
| "完全删除这一部分，我们这里不需要缓存" | 拒绝提议的方法 |
| "队列消费者已经处理了重试，所以这个重试逻辑是多余的。删除它，直接让它失败" | 解释为什么应该更改 |
| "这是错误的，可见性字段需要在列表本身上，而不是在单个项目上。当列表是公开的时，所有项目都是公开的。相应地重构模式部分" | 重定向计划的整个部分 |

然后我把 Claude 发回文档：

```
我在文档中添加了一些注释，处理所有注释并相应地更新文档。先不要实现
```

这个循环重复 1 到 6 次。

**明确的"先不要实现"防护至关重要。** 没有它，Claude 会在它认为计划足够好的那一刻就跳到代码。在我认可之前，它都不够好。

### 为什么这如此有效

Markdown 文件充当我和 Claude 之间的**共享可变状态**。我可以按照自己的节奏思考，精确地指出哪里错了，并在不丢失上下文的情况下重新参与。我不是试图在聊天消息中解释一切。我是在文档中确切的问题位置指出它，并在那里写下我的更正。

这与试图通过聊天消息引导实现根本不同。计划是一个结构化的、完整的规范，我可以整体审查。聊天记录是我必须滚动查看才能重建决策的东西。计划每次都赢。

三轮"我添加了注释，更新计划"可以将一个通用的实现计划转化为一个完美契合现有系统的计划。Claude 在理解代码、提出解决方案和撰写实现方面非常出色。但它不知道我的产品优先级、用户的痛点，或者我愿意做出的工程权衡。**注释循环就是我注入这些判断的方式。**

### 待办事项列表

在开始实现之前，我总是要求一个细粒度的任务分解：

```
在计划中添加一个详细的待办事项列表，包含完成计划所需的所有阶段和单个任务——先不要实现
```

这会创建一个检查清单，在实现过程中作为进度跟踪器。Claude 在完成时标记项目，所以我可以随时查看计划并准确了解进展情况。在运行数小时的会话中特别有价值。

---

## 第三阶段：实现

当计划准备好后，我发出实现命令。我已经将其完善为一个标准的提示词，在不同的会话中重复使用：

```
全部实现。当你完成一个任务或阶段时，在计划文档中将其标记为已完成。在所有任务和阶段完成之前不要停止。不要添加不必要的注释或 jsdocs，不要使用 any 或 unknown 类型。持续运行类型检查以确保你没有引入新问题。
```

这个单一提示词编码了所有重要的事情：

| 指令 | 含义 |
|------|------|
| "全部实现" | 做计划中的所有事情，不要挑挑拣拣 |
| "在计划文档中将其标记为已完成" | 计划是进度的唯一真实来源 |
| "在所有任务和阶段完成之前不要停止" | 不要在流程中暂停等待确认 |
| "不要添加不必要的注释或 jsdocs" | 保持代码整洁 |
| "不要使用 any 或 unknown 类型" | 保持严格类型 |
| "持续运行类型检查" | 尽早发现问题，而不是在最后 |

我在几乎每个实现会话中都使用这个确切的措辞（有轻微变化）。当我说"全部实现"时，每个决策都已经做出并验证。实现变得机械化，而不是创造性的。这是故意的。

**我希望实现是枯燥的。** 创造性的工作发生在注释循环中。一旦计划正确，执行就应该简单明了。

没有计划阶段，通常会发生的情况是 Claude 早早做出一个合理但错误的假设，在其上构建 15 分钟，然后我必须解开一连串的更改。"先不要实现"防护完全消除了这一点。

---

## 实现过程中的反馈

一旦 Claude 在执行计划，我的角色就从架构师转变为监督者。我的提示词变得简短得多。

计划注释可能是一段话，而实现更正通常只有一句话：

- "你没有实现 `deduplicateByTitle` 函数。"
- "你把设置页面建在了主应用中，但它应该在管理应用中，移动它。"

Claude 有计划的完整上下文和正在进行的会话，所以简短的更正就足够了。

**前端工作是最迭代的。** 我在浏览器中测试并快速发出更正：

- "更宽"
- "还是被截断了"
- "有 2px 的间隙"

对于视觉问题，我有时会附加截图。一个未对齐表格的截图比描述问题传达得更快。

**我也经常引用现有代码：**

```
这个表格应该看起来完全像用户表格，相同的表头，相同的分页，相同的行密度。
```

这比从头描述设计要精确得多。成熟代码库中的大多数功能都是现有模式的变体。新的设置页面应该看起来像现有的设置页面。指向参考传达了所有隐式需求，而不需要详细说明。Claude 通常会在做出更正之前阅读参考文件。

当事情走向错误方向时，我不会试图修补它。我通过丢弃 git 更改来恢复和重新确定范围：

```
我恢复了所有内容。现在我想要的只是让列表视图更简洁——其他什么都不做。
```

在恢复后缩小范围几乎总是比试图逐步修复糟糕的方法产生更好的结果。

---

## 掌控主导权

尽管我将执行委托给 Claude，**我从不给它完全的自主权来决定构建什么。** 我在 `plan.md` 文档中完成绝大多数的主动引导。

这很重要，因为 Claude 有时会提出技术上正确但对项目错误的方法。也许方法过于复杂，或者它改变了系统其他部分依赖的公共 API 签名，或者它在有更简单的选择时选择了更复杂的选项。我拥有关于更广泛系统、产品方向和工程文化的上下文，而 Claude 没有。

**计划文档是我注入这些约束的地方。**

---

## 单次长时间会话

我几乎所有工作都在单个长时间会话中完成。不是 15 分钟的快速任务，而是 2-4 小时的专注工作块，Claude 和我解决一个完整的功能或重构。

我没有看到每个人所说的在 50% 上下文窗口后的性能下降。实际上，当我说"全部实现"时，Claude 已经在整个会话中建立了理解：在研究期间阅读文件，在注释循环期间完善其心智模型，吸收我的领域知识更正。

当上下文窗口填满时，Claude 的自动压缩保持了足够的上下文以继续。而且计划文档，这个持久的产物，在压缩中完整保留。我可以随时指向它。

---

## 一句话总结工作流程

> **深入阅读，撰写计划，注释计划直到正确，然后让 Claude 不间断地执行整个计划，同时检查类型。**

就是这样。没有神奇的提示词，没有复杂的系统指令，没有聪明的技巧。只是一个将思考与打字分离的纪律严明的流程。研究防止 Claude 做出无知的更改。计划防止它做出错误的更改。注释循环注入我的判断。实现命令让它在做出每个决策后不受干扰地运行。

试试我的工作流程，你会想知道如果没有一个注释计划文档坐在你和代码之间，你是如何用编码代理发布任何东西的。

---

*标签：[agents](https://boristane.com/tags/agents), [sdlc](https://boristane.com/tags/sdlc)*
